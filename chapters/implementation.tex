\chapter{Implementation}

From a higher-level perspective, there are several subparts of the project that need to cooperate for the app to work well. Firstly, there are the domain objects and stores implemented with the help of MobX. Secondly, there is the view layer created with React Native. The third piece is handling API communication and lastly, there are the native modules for handling job upload (ie. uploading files to Memsource and creating jobs from them) which are the only custom code of the application that is not be written in JavaScript. This chapter explains in depth the solutions to these tasks and issues encountered along the way.


\begin{figure}[H]
	\begin{forest}
		for tree={
			font=\ttfamily,
			grow'=0,
			child anchor=west,
			parent anchor=south,
			anchor=west,
			calign=first,
			inner xsep=7pt,
			edge path={
				\noexpand\path [draw, \forestoption{edge}]
				(!u.south west) +(7.5pt,0) |- (.child anchor) pic {folder} \forestoption{edge label};
			},
			% style for your file node 
			file/.style={edge path={\noexpand\path [draw, \forestoption{edge}]
					(!u.south west) +(7.5pt,0) |- (.child anchor) \forestoption{edge label};},
				inner xsep=2pt,font=\small\ttfamily
			},
			before typesetting nodes={
				if n=1
				{insert before={[,phantom]}}
				{}
			},
			fit=band,
			before computing xy={l=15pt},
		}  
		[js
		[app.js,file
		]
		[api
		]
		[components
		[formComponents
		]
		[jobs
		]
		[projects
		]
		[translationMemories
		]
		]
		[flow
		]
		[global
		]
		[models
		]
		[stores
		]
		[utils
		]
		]
	\end{forest}
	\caption{Simplified folder structure of the project.}
	\label{impl:folders}
\end{figure}

Figure \ref{impl:folders} shows simplified schema of the project structure. Since React Native is makes no assumptions about the rest of the development stack, developer has the freedom to structure the project as they find fit. In my case, I first created dedicated folders for domain objects (models) and stores. All components live in the \texttt{components} directory which is further divided based on where in the application the components are used or what purpose they serve. The api folder contains the objects related to connectivity and communication with Memsource API and the remaining folders provide supporting utilities such as global styles. Native modules are placed higher in the directory structure so they are not visible in the figure.


\section{UI with React Components}

User interfaces made with React consist of components, which are independent and reusable pieces of code. The complete application UI consists of a tree of components. In the case of this project, the root component is defined in \texttt{app.js} in the \texttt{js} directory as can be seen in figure \ref{impl:folders}.

The main way of modifying component behavior is composition - by wrapping a component and adding some functionality, we create a new one. Since the app needs to support lots of CRUD operations we need components for choosing date, choosing one or more items from a small as well as large lists and more. One of the first issues I have encountered is that finding components for forms which would look according to what is customary on both platforms is hard. While there are UI toolkits for React Native such as Shoutem UI Toolkit or NativeBase and community-developed components, none of them offer quite the functionality that we need.

I therefore created wrappers around the basic form components provided by React Native and gave them default styling which is overridable (for example a label or an icon can be added) and mode (for example modal or inline pickers on iOS). All of these options are available under a unified interface of the component, which allows it to be easily used throughout the app. The figure shows an example of different look of ListPicker and DatePicker components on Android and iOS. Note that the pickers on iOS can be displayed both inline and in a modal at the bottom of the screen. Android ListPicker on the other hand, can be displayed in a dialog or as a dropdown.

\begin{figure}[H]
	\includegraphics[width=1\textwidth]{pics/components}
	\caption{Platform-customized behavior of list and date picker components}
	\label{components}
\end{figure}


When using such components in code, one only has to provide them with the information about the icon, the values they need to show, the mode and how they should respond to user action. The logic of how the component should be displayed and styled is hidden inside of it, with the styling being overridable. This way we can construct reusable components with platform-specific behavior.


%As described in the todo section, React native offers several ways of how to handle per-platform customizations. We will use these to provide user with the app handling they are accustomed to. Examples of places that need custom handling are actions that are included in the navbar on Android while they're shown in the bottom toolbar on iOS. Also the navigation has to look differently. 

\section{Stores}

As explained in section \ref{sec:stores}, the information about projects, jobs, and other entities in stored in domain objects, which in turn are kept in stores. It is important that there is always one instance of a particular domain object in memory, and only one instance of a store.

As an example of how a store is implemented, let's consider the project store. In its constructor it accepts (among other) the user store - that way we can clean and refresh the project list in case the active user changes. It also receives apiCaller instance which is used for communication with Memsource API. Projects are stored in a Map, which is typically backed by a hash table that offers constant access time, or by other mechanism that provides sublinear access time. The keys of the Map are projects ids and the values are instances of Project class. That way we can access the stored project instances quickly. This is especially convenient because the projects are displayed in multiple tabs that correspond to filters in Memsource Cloud (all, in progress, overdue, my). One project may be displayed in any number of tabs and even when a project is displayed in all four of them, internally this refers to the same project instance. The advantage of using Map is if we receive a project, we can quickly see whether or not we already have it stored.


\subsection{Connecting Stores with Views}

Clearly, stores need to be made available to React, so that components can visualize the content of the domain objects. For this purpose, the \texttt{mobx-react} package offers the \texttt{Provider} component and inject decorator, thanks to which arbitrary objects can be passed to React components as props. 

As I explained earlier, React app is composed of a tree of components where props are passed from top to bottom. You can either pass the stores as props explicitly through the entire tree which can get tedious, or use Provider, and grant store access for them by using inject. This makes it simple and transparent to "connect" components with relevant parts of the state. Listing \ref{code:provider} shows a simple example of how color prop can be injected. We can still pass the prop explicitly from the parent component, in which case the explicit prop takes precedence. This can be taken advantage of in testing.

\lstinputlisting[label=code:provider,caption=Using MobX Provider and inject]{./code/provider.js}


\section{Upload Module}
Upload module is a native module made to allow users to upload files to Memsource Cloud and create jobs from them. There are important differences in its iOS and Android implementations, but both expose the same interfaces to the JavaScript layer. When talking about the file handling in the native module, I will use the singular form for simplicity, but note the upload module has capabilities for uploading multiple files.


\subsection{Android}
To upload a file as a job, user has to either start the app and navigate to the “add job” screen and select the files for upload from a file picker or start the app externally by opening a file using the Memsource app, for example from the Gmail app or a file browser. 
In both cases, the app receives a uri which points to the file. Note that the file doesn't necessarily need to be on the device, it may as well come from a cloud storage such as OneDrive or Google Drive. The user then sets up various options for the import and taps the “send” button. 
Upon pressing the button, the necessary information consisting of the selected file, upload URL and token is passed to the upload module and upload is started. At the same time, a new item is added to the job list. This item is displayed at the top of the list and, along with a notification, informs user of the running upload.


The module runs a background service whose responsibilities are issuing a notification when the upload starts, when the job is imported or if there was an error. To upload a file, we first need to check whether it is present on the device. If not, file is downloaded using the Storage Access Framework API introduced in Android 4.4. The next step is uploading the file to Memsource and creating a job from it. This is done through  the \texttt{Create New Job} API call which handles the upload and puts the file into a queue where it waits for import. A server backend service dequeues the file and creates a job from it. Because dequeuing and job creation can potentially be long-running operations, the API call returns an ID of the enqueued object immediately after the upload is finished. The Android service then repeatedly polls the \texttt{Asynchronous API} to check the status of the job that is being created. 

Once done, it issues a final notification or, if the user checked the pre-translation checkbox at job upload screen, continues with pre-translation based on project settings. This is another operation that can possibly be long-running and the native module keeps polling the \texttt{Asynchronous API} to check the pre-translation status until it is confirmed. At that point it issues the final notification.


The service repeats its download and upload requests if there was an error. The service is also made to run in the background so that its actions are not disrupted in case the user switches to a different app or even “kills” the app by swiping it away from the screen. The upload service also stores the results of uploads in SharedPreferences.
If the app is still running at the time when the job creation is confirmed, an event is sent to JavaScript and the views are updated. If that is not the case, the response of job creation is processed the next time the app is started. If creation was successful the item which was previously added to the top of the job list is removed and the job data is re-fetched. In case of an error, the item is not removed but instead gives user an option to repeat the upload. The native module is written in Java. 
 

\subsection{iOS}
On iOS, the module provides the same functionality but behaves very differently internally. iOS is much stricter about how background tasks are handled. There is a lot less that needs to be taken care of by the developer and more is taken care of by iOS. This gives the developer a lot less flexibility (this also resulted in a problem with the API) but also results in less coding. The job creation on iOS works in the following way: similarly to Android, files can be selected within the app or sent to the app from an outside application such as iCloud. If a files comes from a remote location, iOS automatically downloads it and saves it to the app’s sandbox from where it is removed when the application exits. The file also has to be uploaded using the API which returns a async id and \texttt{Asynchronous API} is then queried for import status. For the purposes of background tasks, iOS offers the NSURLSession object. Background upload is possible using the uploadTask. However, the developer is not responsible for the upload handling, this is entirely handled by the iOS itself, including possible repeats in case the upload fails. 


Once the file is uploaded, the app is notified about this event by the delegates todo method being called. 


The problem with todo method is that it is not possible to upload a file using the \texttt{multipart/form-data} type; the file uploaded by iOS is sent directly in the body of the request and therefore having a custom request body is impossible unless we write the multipart data directly into the file (which cannot be considered a good practice). Possible workaround here is to use another Memsource API, the File API which allows to upload a file in the request body and returns a file ID which can be used in other API calls. The problem with this approach is that we would need to make two api calls to make the job import happen: first to upload the file and second to call the Create Job api. This poses a possible issue since iOS may decide to not perform our background request. 

iOS uses several pieces of information to decide whether or not a request will be carried out. The decision involves eg. how of often the app is used by the phone's owner or what the battery level is. The exact algorithm is not publicly available. It may therefore happen that the first request for file upload will be honored but the second request for actually creating the job may be ignored. The best possible solution to this is implementing another API which would accept the file in the request body and the numerous parameters sent to the the create job api would be sent as a json string in a special request header. For the time being, I have implemented the described workaround and a better solution on the server side may be implemented later. The iOS native module is written in Swift 3.


\section{State Persistence}

One of the implemented features is having parts of the app's data stored on the device so that it is available right after the app’s startup. This includes information related to projects, so that when the app starts, the user sees their projects immediately, along with a loading indicator which denotes that the projects are being refreshed. MobX itself doesn't come with a mechanism for state persistence, and therefore another library, Serializr was used. Serializr provides a variety of functions for serializing data stored in different data structures and also custom objects. The data that needs to be serialized and the data structure used are described using decorators placed on the member variables of selected classes. The application also stores search history for all of its users. 

While the implemented serialization works well, it poses extra level of complexity; implementing it was a lengthy task partly due to some hard-to-find unexpected behaviors and unhelpful error messages. The (de)serialization, however, is implemented in such way that when an error happens (which is more likely to happen during deserialization), the app falls back to to not deserializing any data and instead loads the data only from the api.


State is serialized upon switching the app into the background. Serializr outputs a json object which is persisted using React Native’s AsyncStorage as a string. Note that storage of user credentials is handled differently and is described in the next section. Upon app start, the objects that hold state are created empty, the json string is deserialized and and all of the information is inserted back into the state objects through setters. 


\subsection{Storing User Credentials}

Communication with the Memsource API requires the user to enter their username and password. The app then asks for a token which is used for the requests to follow. The token validity is limited to 24 hours and the app therefore needs to request a new one once the current token's validity is approaching its expiration date. To be able to ask for a new token, the app needs to have the user credentials at its disposal, and persist them so that it doesn't need to repeatedly ask the user to enter them. Such storage, obviously, needs to be safe and the AsyncStorage used for state persistence does not meet the safety criteria. To store the user credentials, I used a package which internally uses Keychain on iOS and an encrypted SharedPreferences entry on Android. I authored the Android part of the package which is now available as react-native-keychain on npm. 

\section{Data Fetching}

There are some common patterns related to data fetching arising throughout the app. In many places we need to display some data, be able to reload it (using the well known pull down gesture), and be able to load more of the content and append it to the existing data (informally known as infinite loading).

Many of the used APIs use paging, ie. they deliver results in batches of 50 items per request (or less if more aren't available). The app uses this fact to find out if more items can be fetched since the number of the next page to be fetched can be calculated as $next = number \;of\; received \;items / 50$. If a response contains less than 50 items we know there are no more items to be fetched. However, we need to keep in mind that items can be both added and removed to the lists, for example when projects are added. That would give us a page number which is not an integer. In that case we perform a request for a page whose number is the closest lower integer. This may give us items that are already stored in the list, in which case we remove items at indices from $next \cdot 50$ to the end. That way we display the correct data and do not need to make any additional requests.

Also, in some cases we want to limit the number of pages that we fetch so that we do not allow the app to keep too many objects in memory which could cause undesired behavior. 

In some places where data is fetched we want to give the user a possibility to refresh the loaded list (such as in project or job lists) while in other we only offer listing without refreshing. This means we need to control up to two loading indicators that will denote refreshing (that would be the pull down indicator) or loading more content (loading indicator at the bottom of a list). We also need a means for blocking a request if it is already in progress or if is forbidden (because of reaching the limit of number of fetched items or because no more items are available). 

Blocking a request if it already in progress is needed for cases when we eg. scroll down a ListView which has the infinite loading implemented. Infinite loading is implemented using ListView’s onLoadMore function. This function is invoked when a user scrolls down the ListView and arrives at some pre-defined distance from the end of its content. Invocation of this function triggers fetching more items. In case of a poor network connection, fetching might take several seconds during which the user may scroll through the already rendered items and trigger another fetch. We need to prevent this second fetch from happening, otherwise when the returned promise resolves, it would append the results to the end of the list two or more times, causing duplicate entries.
 
If we want to have some universal fetching mechanism, it needs to account for all of these requirements. For this purpose I implemented the ProjectDetailsFetcher module. The most important function it exposes is the fetchProjectDetail function which accepts a project for which it fetches the detail (jobs, translation memories and term bases or other potential items). The other parameters include the field name (eg. jobs), a boolean denoting whether the request is a full reload request (one triggered by the pull down gesture), configuration object (eg. to specify a filter) and page limit that will not allow fetching more than specified number of pages.
ProjectDetailsFetcher internally handles the number of the next page that should be requested for a particular project and property as well as tracking which requests are allowed or not. The fetchProjectDetail function returns a Promise which contains the response data. This data is usually requested from stores. ProjectDetailsFetcher does not handle displaying or hiding the loading indicators, as I have found it to be better to control this from the places where fetching is being requested because it offers more flexibility.




\subsection{Handling Internet Connection Outage}

The application’s functionality is dependent on Internet connection since acquiring all of its data and possible user actions need access to the Memsource API. However, once the application fetches its data, it, of course, stays in the memory and is available for reading. Moreover, the app serializes data which is needed to display the list of projects and the project info screen, which includes projects, clients, domains, subdomains, business units and other details. That way the data is available for reading even if the user starts the app without Internet connection. Moreover, even if internet connection is available, user can see their projects right upon the app's start, along with a loading indicator that denotes refreshing.


When the app is offline, there is a bar displayed at the top of the screen, and it informs the user there is no Internet access. Also, when a user's request times out, they are informed about it via a toast. This behavior however, may change if I find it too intrusive. 


\section{Multi-stage deployment and testing}


One of the advantages of using React Native or hybrid application frameworks is the ability to use services such as Code Push that enable the developer to update the application without going through Apple AppStore or Google Play Store submission process. This is achieved through being able to switch the JavaScript bundle which contains the app’s logic for another one. When a developer wants to publish a new version of the app they create a new JavaScript bundle and upload it to a Code Push server. 
When a user starts the app, it downloads the new bundle (if available) and stores it. In a typical scenario, the bundle would be applied upon the next app start but this is configurable. This way the user receives updates without any interruption on their side. This does not only give us the ability to publish updates at an arbitrary frequency but also offers greater control over the updates, since the user does not influence them.


In the app, I have used the Code Push service which is being developed by Microsoft and currently offered free of charge. 


Other benefits this brings and that I have implemented is multi-stage deployment and testing. For the purposes of our app, three build configurations were set up: debug configuration where code-push is not being used; this configuration is used for everyday development and runs in React Native’s Dev mode.

The second configuration is Staging, which is set up to request the staging version of the JavaScript bundle from Code Push and uses Memsource’s pre-release server at \texttt{cloud 9.memsource.com} to serve its requests. This version is made for testing the application's new features and also its compatibility with the Memsource Cloud version which is the next to be deployed to production. The development mode is not enabled in this configuration and thus the development warnings are not shown. 


Finally, the third setup is for release. This configuration uses the corresponding JavaScript bundle from Code Push to get its updates and is identical with the staging version, with the exception of not having the latest updates that are being tested in staging. This is the version that runs on the phones of the Memsource’s customers. When suitable, the updates made in the staging version can be easily promoted to the release build of the application by a single cli command.

\section{Code Quality Tools}

Due to JavaScript's dynamic nature and the absence of any transformation that would take place before the code starts its execution, it is relatively easy to introduce bugs that only come to light during runtime. There are, however, tools for code quality assurance that help developers find potential bugs before the code is executed. In this project, I have used two such tools which this section shortly describes.

\subsection{Flow - Static Type Checker}

Flow is a static type checker for JavaScript developed by Facebook. It works by using type inference even on plain JavaScript code without any annotations by tracking the type of variables as they are used through the program. Flow therefore allows developer to catch bugs before they run the program, without changing the existing code. 

Flow attempts to infer the types whenever possible, but some JavaScript code can be very dynamic and hard to analyze statically. Flow therefore offers ways to specify types explicitly which also works as a documentation for the developer and for an IDE which can offer a better autocomplete.

Flow supports standard primitive types such as number or string, as well as custom types eg. for application-specific objects. It guards common bugs such as null dereferencing, silent type conversions and many more potential sources of bugs. An example of how flow-typed code can look like, see listing \ref{code:flow}. In this example, Flow would report that the annotated return type of \texttt{string} is incompatible with the return of the \texttt{length} function, which is a \texttt{number}. The listing also shows how to enable Flow checking for a JavaScript module --- simply include \texttt{@flow} in a comment at the top of the file.


\lstinputlisting[label=code:flow,caption=Flow-annotated JavaScript code]{./code/flow.js}

One of very useful features of Flow are maybe types which are denoted by a question mark (eg. \texttt{?string}). When accessing a function or property on an object which is of maybe type, Flow will issue a warning that \texttt{Property cannot be accessed on possibly null or undefined value}. This greatly helps avoiding the "Undefined is not an object" error which is one of the most common ones in JavaScript development. Other handy features include interfaces or guarding that a function doesn't receive too few or too many parameters. I have used Flow extensively throughout the project.

\subsection{ESLint}

ESLint is a linter -- a tool that flags potential problems in source code. ESLint takes the form of a set of rules that the developer specifies and ESLint warns her when the code violates a particular rule. Rules may describe a potential bug in source code (such as calling a function that is not defined) or a desired coding style (such as using semicolons at the end of a line).

ESLint itself does not force any rules onto the developer. Instead, different rule sets can be obtained online and plugged into the project. Choosing such rule set is often a matter of personal preference or the technology that the project uses. For example, there are React Native-specific rules that eg. warn about having unused style definitions in the component code.

\section{Navigation}

By navigation, in the context of React Native, I mean transitioning between different screens of the app. Navigation integrates with the components and also stores very closely, because many parts of the code will want to navigate to a different component as a response to user input or network event, so the navigation solution is of great importance. 

RN started off with two solutions for navigation - the Navigator and NavigatorIOS. Navigator is implemented entirely in JavaScript, runs on both platforms and tries to mimic the appearance of native navigation, while NavigatorIOS leverages the native navigation of iOS.
They originally started as two competing implementations solving the same problem (todo ref) with the goal of assessing which of the two solutions should be supported further on. Ultimately, the Navigator solution was found to be better for reasons described later on, and Facebook used it in the F8 and Facebook ads applications. 


There is one notable drawback to Navigator - it is only trying to mimic the native navigation. This includes navigation bar with its animations, as well as transitions to and from different scenes of the app and implementation of the swipe back gesture. This, to a certain extent, can negative affect the user experience.
Having navigation controlled by JavaScript has its benefits - most importantly it allows for complete control of the navigation state, while with NavigatorIOS, some information sent from JavaScript to the native layer gets stored in the native code where it is managed by iOS internally which makes it hard to keep the information in JavaScript up to date. The difficulty of keeping JavaScript in sync with iOS and the fact it only works on one platform were the main reasons why Facebook decided to favor the Navigator.

Some would say that not using the native navigation breaks the promise of React Native - that is to be able to create apps that are indistinguishable from native ones. This is why Wix (an Israeli mobile and web development company) is working on a native navigation for react native. At the time of writing, there is not a stable release of this package available which is why I didn't use it.

Over the course of time new issues with using Navigator emerged and there was a need to come up with a better way of managing the navigation state. For example, the original Navigator becomes hard to work with in case we use several instances of it. For example, the application I have developed uses three different navigation components - one StackNavigation as a root navigator. The root navigator contains another StackNavigation where the vast majority of the app's content is pushed. In some places, however, I wanted to display modal windows. The modals are pushed onto the master navigator so that they are displayed in the foreground. The modal window contains another StackNavigation of its own, which yields a total of three navigators, but for applications that use a tab-based navigation or drawer navigation, that number is very likely higher. 


At the time when I started working on the project, the new solution to navigation was already present in the RN core and was named NavigationExperimental. However, since NavigationExperimental is only a set of low-level components, people started writing libraries around them to provide a more feature-rich experience for the developers. In the end, I have settled with a library called ex-navigation. It offers some needed functionality out of the box and allows to customize the behavior for iOS and Android such as handling the navigation bar, animations and back gesture on iOS as well as the back button handling on Android. Most importantly it works well with several navigators which can be managed independently and offers better animation performance - on Android, the animations are controlled from the native layer.

\section{Issues}

There were a number of issues encountered throughout the development, caused by different factors such as React Native's immaturity and frequent releases where new version is shipped every other week and updating is not always straightforward due to breaking changes (although this is changing to one release per month as of January 2017), lack of quality documentation, or my effort to create a partially different UIs on each platform so that the user experience is on par with what the user would get in an application designed specifically for iOS or Android. This sometimes led to dead ends such as when I had to replace the entire navigation solution for a new one. Navigation as a whole is an interesting topic, which is why I devoted an entire section to it.
Another issue is minor differences in behavior on each platform -- the component appearance on iOS may not always be the same as the one on Android. This involves borders, border radius or animations. However, given React Native's complexity --- the library uses JavaScript, Java, Objective-C, C++ and also C --- it does a very good job in abstracting the platform away.
Other very painful issue, although visible only when rendering large UIs, are animations which are controlled from the JavaScript thread. This means that the JavaScript thread has to periodically send commands to the native layer for the animation to run. If the JavaScript thread has too much work on it, issuing the command is delayed and the result is a laggy animation. This issue, however, is already partially solved and offloading the animations from the JavaScript thready will probably be fully functional in the first months of 2017. 
%Also, the fact that React Native is not a framework gives developer the freedom to do things in different ways, which also means that the first way a developer reaches for does not always turn out to be the best one. 

Throughout the development of the application, I have contributed to the following projects by bug fixes or code and documentation improvements: react-native-keychain, mobx-utils, react-native-scrollable-tab-view, ex-navigation, react-native-router-flux, serializr, react-native-android-checkbox, mobx, react-native. 




