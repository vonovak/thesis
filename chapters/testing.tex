\chapter{Testing and Crash Reporting}

The Android and iOS versions of the application were implemented in parallel, mostly on my personal machine with Ubuntu 16.04 and my Nexus 5 phone with Android 6.0.1, following a verification and fine-tuning for iOS. The development phone for iOS was iPhone 5C running the latest version of iOS which was available at the time. 

I have also used the iPhone and Android emulators for development and to see how the application looks with different screen resolutions and OS versions (the latter is especially relevant for Android). However, having access to real devices was crucial, since only a real device can give a feeling of how well touchable elements respond to touches, how the software keyboard influences the displayed content and how the application functions in terms of performance. A real iPhone device was also needed for implementing the native module for creating jobs, since the background capabilities of NSURLSession of an iPhone emulator do not fully correspond to the behavior of a real device.

All throughout the development, the application was receiving its data from Memsource servers, ie. I have not used any server implementation specifically for the development.


\section{Unit Testing}
The lowest level upon which the application is tested is unit testing. I have chosen Jest \footnote{http://facebook.github.io/jest/} for implementing the unit tests. Jest, like several other tools I have used, is a library actively developed by Facebook and is open source. 

It offers essential functionality similar to other popular Javascript test runners (e.g. AVA or Mocha), such as making assertions upon the results of tested code, creating mocks and also offers snapshot testing, which is a React-specific feature for testing the structure of React components without directly rendering them. Snapshot testing is a very useful feature especially in React Native as it allows to test component appearance without the need for rendering the UI on a device or emulator. 

Jest creates a snapshot that captures the necessary information for component rendering. When the component changes, the snapshot changes as well, and we're notified of this fact during testing and also by version control when the change is being merged since the snapshot files live alongside the code. 

Snapshot testing currently has the drawback of not being able to trigger and capture possible changes in the inner state of the component (if there is any state), ie. snapshot testing only considers the componentâ€™s props. This, however, is a subject to change in one of the future releases of Jest, which is being developed at a quick pace.

Since a React Native app is a native application, we can use the same testing frameworks that we would use for testing any other native app on ios or Android. 

todo popsat kolik jich ej jak jsem je pouzil atd - vystupy

\section{Testing With Users}



\section{Crash Reporting}


One of the requirements is the ability to collect crash reports from users running the application so that we can observe how it functions on their devices and react to potential issues. 

There are several services which provide crash reporting as well as means for collecting information about how the app is used, similar to analytics as it is on the web. One of such solutions which is widely used and also has community-developed binding for React Native is called Fabric and is provided by Twitter free of charge for both ios and Android. I have incorporated this service into both ios and Android versions of the app. 

While it does report the application crashes, I am not completely happy with how the reported issues are presented in the Fabric dashboard. In particular, when a crash happens in the Javascript layer of the application, the information is merely passed to the native module which backs the Javascript module. In the native module, an exception is thrown and its information is collected and recorded by Crashlytics. The problem with this approach is that all exceptions are thrown from exactly the same place and crashlytics considers all these bugs to be a single bug. This makes working with crashlytics uncomfortable. I will continue investigating further possibilities in this area. 